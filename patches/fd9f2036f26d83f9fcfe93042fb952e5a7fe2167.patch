diff --git a/src/gn/filesystem_utils.cc b/src/gn/filesystem_utils.cc
index 7a7078e..811cc52 100644
--- a/src/gn/filesystem_utils.cc
+++ b/src/gn/filesystem_utils.cc
@@ -13,10 +13,12 @@
 #include "gn/location.h"
 #include "gn/settings.h"
 #include "gn/source_dir.h"
+#include "gn/target.h"
 #include "util/build_config.h"
 
 #if defined(OS_WIN)
 #include <windows.h>
+#include <direct.h>
 #endif
 
 namespace {
@@ -178,8 +180,7 @@ void AppendFixedAbsolutePathSuffix(const BuildSettings* build_settings,
                                    OutputFile* result) {
   const std::string& build_dir = build_settings->build_dir().value();
 
-  if (base::StartsWith(source_dir.value(), build_dir,
-                       base::CompareCase::SENSITIVE)) {
+  if (source_dir.value().starts_with(build_dir)) {
     size_t build_dir_size = build_dir.size();
     result->value().append(&source_dir.value()[build_dir_size],
                            source_dir.value().size() - build_dir_size);
@@ -639,33 +640,75 @@ void ConvertPathToSystem(std::string* path) {
 #endif
 }
 
-std::string MakeRelativePath(const std::string& input,
-                             const std::string& dest) {
 #if defined(OS_WIN)
-  // Make sure that absolute |input| path starts with a slash if |dest| path
-  // does. Otherwise skipping common prefixes won't work properly. Ensure the
-  // same for |dest| path too.
-  if (IsPathAbsolute(input) && !IsSlash(input[0]) && IsSlash(dest[0])) {
-    std::string corrected_input(1, dest[0]);
-    corrected_input.append(input);
-    return MakeRelativePath(corrected_input, dest);
+std::string GetPathWithDriveLetter(std::string_view path) {
+if (!IsPathAbsolute(path) || !IsSlash(path[0]))
+  return std::string(path);
+
+  int drive = _getdrive();
+  DCHECK(drive > 0 && drive <= 26);
+
+  std::string ret;
+  ret.reserve(2 + path.size());
+  ret.push_back('A' + drive - 1);
+  ret.push_back(':');
+  ret += path;
+  return ret;
+}
+
+// Regulate path if it is an absolute path.
+std::string RegulatePathIfAbsolute(std::string_view path) {
+  CHECK(!path.empty());
+  bool is_start_slash = IsSlash(path[0]);
+
+  // 1. /C:/ -> C:/
+  if (path.size() > 3 && is_start_slash &&
+        base::IsAsciiAlpha(path[1]) && path[2] == ':') {
+    return RegulatePathIfAbsolute(path.substr(1));
   }
-  if (IsPathAbsolute(dest) && !IsSlash(dest[0]) && IsSlash(input[0])) {
-    std::string corrected_dest(1, input[0]);
-    corrected_dest.append(dest);
-    return MakeRelativePath(input, corrected_dest);
+
+  bool is_path_absolute = IsPathAbsolute(path);
+
+  // 2. /Path -> ($PWD's Drive):/Path
+  if (is_path_absolute && is_start_slash) {
+    return GetPathWithDriveLetter(path);
   }
 
-  // Make sure that both absolute paths use the same drive letter case.
+  // 3. c:/ -> C:/
+  std::string ret(path);
+  if (is_path_absolute && !is_start_slash) {
+    ret[0] = base::ToUpperASCII(path[0]);
+  }
+
+  return ret;
+}
+#endif
+
+std::string MakeRelativePath(std::string_view input,
+                             std::string_view dest) {
+#if defined(OS_WIN)
+  // Regulate the paths.
+  std::string input_regulated = RegulatePathIfAbsolute(input);
+  std::string dest_regulated = RegulatePathIfAbsolute(dest);
+
+  input = input_regulated;
+  dest = dest_regulated;
+
+  // On Windows, it is invalid to make a relative path across different
+  // drive letters. A relative path cannot span over different drives.
+  // For example:
+  //    Input          : D:/Path/Any/Where
+  //    Dest           : C:/Path/In/Another/Drive
+  //    Invalid Result : ../../../../../D:/Path/Any/Where
+  //    Correct Result : D:/Path/Any/Where
+  // It will at least make ninja fail.
+  // See: https://bugs.chromium.org/p/gn/issues/detail?id=317
   if (IsPathAbsolute(input) && IsPathAbsolute(dest) && input.size() > 1 &&
       dest.size() > 1) {
-    int letter_pos = base::IsAsciiAlpha(input[0]) ? 0 : 1;
-    if (input[letter_pos] != dest[letter_pos] &&
-        base::ToUpperASCII(input[letter_pos]) ==
-            base::ToUpperASCII(dest[letter_pos])) {
-      std::string corrected_input = input;
-      corrected_input[letter_pos] = dest[letter_pos];
-      return MakeRelativePath(corrected_input, dest);
+    if (input[0] != dest[0]) {
+      // If the drive letters are differnet, we have no choice but use
+      // the absolute path of input for correctness.
+      return input_regulated;
     }
   }
 #endif
@@ -679,9 +722,11 @@ std::string MakeRelativePath(const std::string& input,
   size_t common_prefix_len = 0;
   size_t max_common_length = std::min(input.size(), dest.size());
   for (size_t i = common_prefix_len; i <= max_common_length; i++) {
-    if ((IsSlash(input[i]) || input[i] == '\0') && IsSlash(dest[i]))
+    if (dest.size() == i)
+      break;
+    if ((input.size() == i || IsSlash(input[i])) && IsSlash(dest[i]))
       common_prefix_len = i + 1;
-    else if (input[i] != dest[i])
+    else if (input.size() == i || input[i] != dest[i])
       break;
   }
 
@@ -693,7 +738,7 @@ std::string MakeRelativePath(const std::string& input,
 
   // Append any remaining unique input.
   if (common_prefix_len <= input.size())
-    ret.append(&input[common_prefix_len], input.size() - common_prefix_len);
+    ret.append(input.begin() + common_prefix_len, input.end());
   else if (input.back() != '/' && !ret.empty())
     ret.pop_back();
 
@@ -708,8 +753,7 @@ std::string RebasePath(const std::string& input,
                        const SourceDir& dest_dir,
                        std::string_view source_root) {
   std::string ret;
-  DCHECK(source_root.empty() ||
-         !base::EndsWith(source_root, "/", base::CompareCase::SENSITIVE));
+  DCHECK(source_root.empty() || !source_root.ends_with("/"));
 
   bool input_is_source_path =
       (input.size() >= 2 && input[0] == '/' && input[1] == '/');
@@ -1025,25 +1069,10 @@ OutputFile GetSubBuildDirAsOutputFile(const BuildDirContext& context,
   OutputFile result = GetBuildDirAsOutputFile(context, type);
 
   if (source_dir.is_source_absolute()) {
-    std::string_view build_dir = context.build_settings->build_dir().value();
-    std::string_view source_dir_path = source_dir.value();
-    if (source_dir_path.substr(0, build_dir.size()) == build_dir) {
-      // The source dir is source-absolute, but in the build directory
-      // (e.g. `//out/Debug/gen/src/foo.cc` or
-      // `//out/Debug/toolchain1/gen/foo.cc`), which happens for generated
-      // sources. In this case, remove the build directory prefix, and replace
-      // it with `BUILD_DIR`. This will create results like `obj/BUILD_DIR/gen`
-      // or `toolchain2/obj/BUILD_DIR/toolchain1/gen` which look surprising,
-      // but guarantee unicity.
-      result.value().append("BUILD_DIR/");
-      result.value().append(&source_dir_path[build_dir.size()],
-                            source_dir_path.size() - build_dir.size());
-    } else {
-      // The source dir is source-absolute, so we trim off the two leading
-      // slashes to append to the toolchain object directory.
-      result.value().append(&source_dir.value()[2],
-                            source_dir.value().size() - 2);
-    }
+    // The source dir is source-absolute, so we trim off the two leading
+    // slashes to append to the toolchain object directory.
+    result.value().append(&source_dir.value()[2],
+                          source_dir.value().size() - 2);
   } else {
     // System-absolute.
     AppendFixedAbsolutePathSuffix(context.build_settings, source_dir, &result);
diff --git a/src/gn/ninja_c_binary_target_writer_unittest.cc b/src/gn/ninja_c_binary_target_writer_unittest.cc
index 9476193..6056c36 100644
--- a/src/gn/ninja_c_binary_target_writer_unittest.cc
+++ b/src/gn/ninja_c_binary_target_writer_unittest.cc
@@ -405,18 +405,18 @@ TEST_F(NinjaCBinaryTargetWriterTest, NoHardDepsToNoPublicHeaderTarget) {
       "target_out_dir = obj/foo\n"
       "target_output_name = gen_obj\n"
       "\n"
-      "build obj/BUILD_DIR/gen_obj.generated.o: cxx generated.cc"
+      "build obj/out/Debug/gen_obj.generated.o: cxx generated.cc"
       " || obj/foo/generate.stamp\n"
       "  source_file_part = generated.cc\n"
       "  source_name_part = generated\n"
       "\n"
-      "build obj/foo/gen_obj.stamp: stamp obj/BUILD_DIR/gen_obj.generated.o"
+      "build obj/foo/gen_obj.stamp: stamp obj/out/Debug/gen_obj.generated.o"
       // The order-only dependency here is strictly unnecessary since the
       // sources list this as an order-only dep.
       " || obj/foo/generate.stamp\n";
 
   std::string obj_str = obj_out.str();
-  EXPECT_EQ(std::string(obj_expected), obj_str);
+  EXPECT_EQ(obj_expected, obj_str);
 
   // A shared library depends on gen_obj, having corresponding header for
   // generated obj.
@@ -442,7 +442,7 @@ TEST_F(NinjaCBinaryTargetWriterTest, NoHardDepsToNoPublicHeaderTarget) {
       "target_output_name = libgen_lib\n"
       "\n"
       "\n"
-      "build ./libgen_lib.so: solink obj/BUILD_DIR/gen_obj.generated.o"
+      "build ./libgen_lib.so: solink obj/out/Debug/gen_obj.generated.o"
       // The order-only dependency here is strictly unnecessary since
       // obj/out/Debug/gen_obj.generated.o has dependency to
       // obj/foo/gen_obj.stamp
diff --git a/src/gn/substitution_writer_unittest.cc b/src/gn/substitution_writer_unittest.cc
index eaa521a..fc3c446 100644
--- a/src/gn/substitution_writer_unittest.cc
+++ b/src/gn/substitution_writer_unittest.cc
@@ -45,12 +45,6 @@ TEST(SubstitutionWriter, ApplyPatternToSource) {
   SourceFile result = SubstitutionWriter::ApplyPatternToSource(
       nullptr, setup.settings(), pattern, SourceFile("//foo/bar/myfile.txt"));
   ASSERT_EQ("//out/Debug/gen/foo/bar/myfile.tmp", result.value());
-
-  result = SubstitutionWriter::ApplyPatternToSource(
-      nullptr, setup.settings(), pattern,
-      SourceFile("//out/Debug/gen/generated_file.cc"));
-  ASSERT_EQ("//out/Debug/gen/BUILD_DIR/gen/generated_file.tmp", result.value())
-      << result.value();
 }
 
 TEST(SubstitutionWriter, ApplyPatternToSourceAsOutputFile) {
